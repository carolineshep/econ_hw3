---
title: "sandy_code"
author: "Caroline Shepherd"
date: "5/5/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(janitor)
library(rootSolve)
library(here)
library(cowplot)

carbon <- read_csv(here("HW3_data.csv")) %>% 
  select(-1) %>% 
  clean_names

low_lm <- lm(price_cents  ~ q_low_kwh, data=carbon)
high_lm <- lm(price_cents ~ q_high_kwh, data=carbon)

# need to rearrange the parameter to get Q(P)! 

# Qgg = Qlow(P) + Qlow(h) 

# Importantly, since they-intercepts are different, we know that Qagg(P) will have a kink. I include an ifelse() statement to take
# care of the kink.

# define a function to get demand

demand <- function(p, model){
  q <- (p - model$coefficients[[1]])/model$coefficients[[2]]
  q <- ifelse(q<0,0,q)
  return(q)
}

# for each p level, return estimated aggregate demand
demand_agg <- function(p){
  q <- demand(p, model_demand_l) + demand(p, model_demand_h)
  return(q)
}

price = seq(0, 30, length.out = 100)
Qagg <- map(price, demand_agg) %>% unlist()

df<- tibble(Qagg = Qagg, price = price)

ggplot(df, aes(Qagg, price)) +
  geom_line()

# I also define functions for calculating the consumer surplus:

CS <- function(p, model){
  q <- demand(p, model)
  cs <- 0.5*(model$coefficients[[1]] - p)*q
  return(cs)
}

CS_agg <- function(p){
  cs <- CS(p,model_demand_l) + CS(p,model_demand_h)
  return(cs)
}
```


```{r}
# Low demand graph
low_d_reg <- ggplot(data = carbon, aes(x = q_low_kwh, y = price_cents)) +
  theme_classic() +
  geom_line() +
  geom_abline(intercept = low_lm$coefficients[1], slope = low_lm$coefficients[2], color = 'red') +
  labs(x = 'Low Income Electricity (kWh) Demand',
       y = 'Price ($)')

# High demand graph
high_d_reg <- ggplot(data = carbon, aes(x = q_high_kwh, y = price_cents)) +
  theme_classic() +
  geom_line() +
  geom_abline(intercept = high_lm$coefficients[1], slope = high_lm$coefficients[2], color = 'red') +
  labs(x = 'High Income Electricity (kWh) Demand',
       y = 'Price ($)')

plot_grid(low_d_reg, high_d_reg, ncol = 2)
```

```{r}

#storing intercepts and slopes as objects for high and low demand
low_int <- low_lm$coefficients[1]
low_slp <- low_lm$coefficients[2]
high_int <- high_lm$coefficients[1]
high_slp <- high_lm$coefficients[2]

# Creating functions for both demand groups for graphing
d_low <- function(q) {low_slp*q + low_int}
d_high <- function(q) {high_slp*q + high_int}

# Creating an overall demand function for calculations
dem <- function(p, model){
  q <- (p - model$coefficients[[1]])/model$coefficients[[2]]
  q <- ifelse(q<0,0,q)
  return(q)
}

# Creating an aggregate demand function
dem_agg <- function(p){
  q <- dem(p, low_lm) + dem(p, high_lm)
  return(q)
}

# Creating a sequence to map the aggregate demand function for plotting
price = seq(0, 32, length.out = 100)
qagg <- map(price, dem_agg) %>% 
  unlist()

# Putting the sequence into a dataframe
df <- tibble(qagg = qagg, price = price)

# Storing the intercept and slope of the aggregate
d_agg_slp <- (0-low_int)/(dem_agg(0)-dem_agg(low_int))
d_agg_int <- 0 - d_agg_slp*dem_agg(0)
d_agg_plot <- function(q) {d_agg_slp*q + d_agg_int}




```


